Simple increment/decrement contract
  $ ../bin/tunacc_test.exe $PWD/increment.tz
  
  (module
    (import "env" "pair" (func $pair (param i64 i64) (result i64)))
  (import "env" "unpair" (func $unpair (param i64)))
  (import "env" "z_add" (func $z_add (param i64 i64) (result i64)))
  (import "env" "z_sub" (func $z_sub (param i64 i64) (result i64)))
  (import "env" "compare" (func $compare (param i64 i64) (result i64)))
  (import "env" "car" (func $car (param i64) (result i64)))
  (import "env" "cdr" (func $cdr (param i64) (result i64)))
  (import "env" "some" (func $some (param i64) (result i64)))
  (import "env" "nil" (func $nil (result i64)))
  (import "env" "zero" (func $zero (result i64)))
  (import "env" "empty_set" (func $empty_set (result i64)))
  (import "env" "sender" (func $sender (result i64)))
  (import "env" "map_get" (func $map_get (param i64 i64) (result i64)))
  (import "env" "mem" (func $mem (param i64 i64) (result i64)))
  (import "env" "update" (func $update (param i64 i64 i64) (result i64)))
  (import "env" "iter" (func $iter (param i64 funcref) (result i64)))
  (import "env" "if_left" (func $if_left (param i64) (result i32)))
  (import "env" "if_none" (func $if_none (param i64) (result i32)))
  (import "env" "if_cons" (func $if_cons (param i64) (result i32)))
  (import "env" "isnat" (func $isnat (param i64) (result i64)))
  (import "env" "not" (func $not (param i64) (result i64)))
  (import "env" "or" (func $or (param i64 i64) (result i64)))
  (import "env" "deref_bool" (func $deref_bool (param i64) (result i32)))
  (import "env" "neq" (func $neq (param i64) (result i64)))
  (import "env" "failwith" (func $failwith (param i64)))
  (import "env" "get_n" (func $get_n (param i32 i64) (result i64)))
  (import "env" "exec" (func $exec (param i64 i64) (result i64)))
  (import "env" "apply" (func $apply (param i64 i64) (result i64)))
  (import "env" "const" (func $const (param i32) (result i64)))
  (import "env" "get_some" (func $get_some (param i64) (result i64)))
  (import "env" "abs" (func $abs (param i64) (result i64)))
  (import "env" "lt" (func $lt (param i64) (result i64)))
  (import "env" "closure" (func $closure (param i32) (result i64)))
  (import "env" "left" (func $left (param i64) (result i64)))
  (import "env" "right" (func $right (param i64) (result i64)))
  (import "env" "cons" (func $cons (param i64 i64) (result i64)))
  (import "env" "transfer_tokens" (func $transfer_tokens (param i64 i64 i64) (result i64)))
  (import "env" "address" (func $address (param i64) (result i64)))
  (import "env" "self" (func $self (result i64)))
  
    (global $mode i32 (i32.const 0))
  
    (memory 1)
    (global $sp (mut i32) (i32.const 4000)) ;; stack pointer
    (global $sh_sp (mut i32) (i32.const 1000)) ;;shadow_stack stack pointer
  
    (global $__stack_base i32 (i32.const 32768))
  
    (func $dip (param $n i32) (result)
      (local $stop i32)
      (local $sp' i32)
      (local $sh_sp' i32)
      (local.set $stop (i32.const 0))
      (local.set $sp'  (global.get $sp))
      (local.tee $sh_sp' (i32.sub (global.get $sh_sp) (local.get $n)))
      global.set $sh_sp
      (loop $l
        (i32.mul (i32.const 8) (i32.add (global.get $__stack_base) (i32.add (local.get $sh_sp') (local.get $stop))))
        (i64.load (i32.mul (i32.const 8) (i32.add (local.get $sp') (local.get $stop))))
        i64.store
        (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))
        (local.get $n)
        i32.ne
        br_if $l)
  
      (global.set $sp
      (i32.add
        (local.get $sp') (local.get $n))))
  
    (func $undip (param $n i32) (result)
      (local $stop i32)
      (local $sp' i32)
      (local $sh_sp' i32)
      (local.tee $sp'  (i32.sub (global.get $sp) (local.get $n)))
      global.set $sp
      (local.set $sh_sp' (global.get $sh_sp))
      (local.set $stop (i32.const 0))
      (loop $l
        (i32.mul (i32.const 8) (i32.add (local.get $sp') (local.get $stop)))
        (i64.load
          (i32.add
            (global.get $__stack_base)
            (i32.mul (i32.const 8) (i32.add (local.get $sh_sp') (local.get $stop)))))
        (i64.store)
        (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))
        (local.get $n)
        i32.ne
        br_if $l)
      (global.set $sh_sp (i32.add (local.get $sh_sp') (local.get $n))))
  
    (func $dup (param $n i32) (result)
      (i64.load (i32.mul (i32.const 8) (i32.add (global.get $sp) (local.get $n))))
      (call $push))
  
    (func $swap (param) (result)
      (local $v1 i64)
      (local $v2 i64)
      (local.set $v1 (call $pop))
      (local.set $v2 (call $pop))
      (call $push (local.get $v1))
      (call $push (local.get $v2)))
  
    (func $dug (param $n i32) (result)
      (local $idx i32)
      (local $loop_idx i32)
      (local $sp' i32)
      (local $top i64)
      (local.set $sp' (i32.add (global.get $sp) (local.get $n)))
      (i32.mul (i32.const 8) (local.tee $idx (global.get $sp)))
      (local.tee $loop_idx)
      i64.load
      local.set $top
      (loop $loop
        (i32.mul (i32.const 8) (local.get $idx))
        (i32.mul (i32.const 8) (i32.add (local.get $loop_idx) (i32.const 1)))
        local.tee $loop_idx
        i64.load
        i64.store
        (local.set $idx (i32.add (local.get $idx) (i32.const 1)))
        (local.get $idx)
        (local.get $sp')
        i32.lt_u
        br_if $loop)
  
      (i64.store (i32.mul (i32.const 8) (local.get $sp')) (local.get $top)))
  
    (func $dig (param $n i32) (result)
      (local $idx i32)
      (local $loop_idx i32)
      (local $sp' i32)
      (local $digged i64)
      (local.set $sp' (global.get $sp))
      (i32.mul (i32.const 8) (local.tee $idx (i32.add (local.get $sp') (local.get $n))))
      (local.tee $loop_idx)
      (i64.load)
      local.set $digged
      (loop $loop
        (i32.mul (i32.const 8) (local.get $idx))
        (i32.sub (local.get $loop_idx) (i32.const 1))
        local.tee $loop_idx
        i32.const 8
        i32.mul
        i64.load
        i64.store
        (local.set $idx (i32.sub (local.get $idx) (i32.const 1)))
        (local.get $sp')
        (local.get $loop_idx)
        i32.lt_u
        br_if $loop)
      (i64.store (i32.mul (i32.const 8) (global.get $sp)) (local.get $digged)))
  
    (func $pop (result i64)
      (local $spp i32)
      (i32.mul (i32.const 8) (local.tee $spp (global.get $sp)))
      i64.load
      (global.set $sp (i32.add (local.get $spp) (i32.const 1))))  ;;set stackptr
  
    (func $push (param $value i64) (result)
      (local $spp i32)
      (i32.mul (i32.const 8) (local.tee $spp (i32.sub (global.get $sp) (i32.const 1)) ))
      (i64.store (local.get $value))
      (global.set $sp (local.get $spp)))  ;;set stackptr
  
    (func $drop (param $n i32) (result)
      (global.set $sp (i32.add (global.get $sp) (local.get $n))))  ;;set stackptr
  
    (table $closures funcref (elem ))
  
  
    (func $main (param $v1 i64) (result i64)
      (local $1 i64)
      (call $push (local.get $v1))
      (call $unpair (call $pop))
  (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $swap)
  (call $push (call $z_sub (call $pop) (call $pop)))) (else (call $push (call $z_add (call $pop) (call $pop)))))) (else (call $drop (i32.const 2))
  (call $push (call $const (i32.const 0))) (; 0 ;)))
  (call $push (call $nil))
  (call $push (call $pair (call $pop) (call $pop)))
      (call $pop))
  
    (export "push" (func $push))
    (export "pop" (func $push))
    (export "main" (func $main)))
  

FA2 with only transfer semantics
  $ ../bin/tunacc_test.exe fa2_no_metadata.tz
  
  (module
    (import "env" "pair" (func $pair (param i64 i64) (result i64)))
  (import "env" "unpair" (func $unpair (param i64)))
  (import "env" "z_add" (func $z_add (param i64 i64) (result i64)))
  (import "env" "z_sub" (func $z_sub (param i64 i64) (result i64)))
  (import "env" "compare" (func $compare (param i64 i64) (result i64)))
  (import "env" "car" (func $car (param i64) (result i64)))
  (import "env" "cdr" (func $cdr (param i64) (result i64)))
  (import "env" "some" (func $some (param i64) (result i64)))
  (import "env" "nil" (func $nil (result i64)))
  (import "env" "zero" (func $zero (result i64)))
  (import "env" "empty_set" (func $empty_set (result i64)))
  (import "env" "sender" (func $sender (result i64)))
  (import "env" "map_get" (func $map_get (param i64 i64) (result i64)))
  (import "env" "mem" (func $mem (param i64 i64) (result i64)))
  (import "env" "update" (func $update (param i64 i64 i64) (result i64)))
  (import "env" "iter" (func $iter (param i64 funcref) (result i64)))
  (import "env" "if_left" (func $if_left (param i64) (result i32)))
  (import "env" "if_none" (func $if_none (param i64) (result i32)))
  (import "env" "if_cons" (func $if_cons (param i64) (result i32)))
  (import "env" "isnat" (func $isnat (param i64) (result i64)))
  (import "env" "not" (func $not (param i64) (result i64)))
  (import "env" "or" (func $or (param i64 i64) (result i64)))
  (import "env" "deref_bool" (func $deref_bool (param i64) (result i32)))
  (import "env" "neq" (func $neq (param i64) (result i64)))
  (import "env" "failwith" (func $failwith (param i64)))
  (import "env" "get_n" (func $get_n (param i32 i64) (result i64)))
  (import "env" "exec" (func $exec (param i64 i64) (result i64)))
  (import "env" "apply" (func $apply (param i64 i64) (result i64)))
  (import "env" "const" (func $const (param i32) (result i64)))
  (import "env" "get_some" (func $get_some (param i64) (result i64)))
  (import "env" "abs" (func $abs (param i64) (result i64)))
  (import "env" "lt" (func $lt (param i64) (result i64)))
  (import "env" "closure" (func $closure (param i32) (result i64)))
  (import "env" "left" (func $left (param i64) (result i64)))
  (import "env" "right" (func $right (param i64) (result i64)))
  (import "env" "cons" (func $cons (param i64 i64) (result i64)))
  (import "env" "transfer_tokens" (func $transfer_tokens (param i64 i64 i64) (result i64)))
  (import "env" "address" (func $address (param i64) (result i64)))
  (import "env" "self" (func $self (result i64)))
  
    (global $mode i32 (i32.const 0))
  
    (memory 1)
    (global $sp (mut i32) (i32.const 4000)) ;; stack pointer
    (global $sh_sp (mut i32) (i32.const 1000)) ;;shadow_stack stack pointer
  
    (global $__stack_base i32 (i32.const 32768))
  
    (func $dip (param $n i32) (result)
      (local $stop i32)
      (local $sp' i32)
      (local $sh_sp' i32)
      (local.set $stop (i32.const 0))
      (local.set $sp'  (global.get $sp))
      (local.tee $sh_sp' (i32.sub (global.get $sh_sp) (local.get $n)))
      global.set $sh_sp
      (loop $l
        (i32.mul (i32.const 8) (i32.add (global.get $__stack_base) (i32.add (local.get $sh_sp') (local.get $stop))))
        (i64.load (i32.mul (i32.const 8) (i32.add (local.get $sp') (local.get $stop))))
        i64.store
        (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))
        (local.get $n)
        i32.ne
        br_if $l)
  
      (global.set $sp
      (i32.add
        (local.get $sp') (local.get $n))))
  
    (func $undip (param $n i32) (result)
      (local $stop i32)
      (local $sp' i32)
      (local $sh_sp' i32)
      (local.tee $sp'  (i32.sub (global.get $sp) (local.get $n)))
      global.set $sp
      (local.set $sh_sp' (global.get $sh_sp))
      (local.set $stop (i32.const 0))
      (loop $l
        (i32.mul (i32.const 8) (i32.add (local.get $sp') (local.get $stop)))
        (i64.load
          (i32.add
            (global.get $__stack_base)
            (i32.mul (i32.const 8) (i32.add (local.get $sh_sp') (local.get $stop)))))
        (i64.store)
        (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))
        (local.get $n)
        i32.ne
        br_if $l)
      (global.set $sh_sp (i32.add (local.get $sh_sp') (local.get $n))))
  
    (func $dup (param $n i32) (result)
      (i64.load (i32.mul (i32.const 8) (i32.add (global.get $sp) (local.get $n))))
      (call $push))
  
    (func $swap (param) (result)
      (local $v1 i64)
      (local $v2 i64)
      (local.set $v1 (call $pop))
      (local.set $v2 (call $pop))
      (call $push (local.get $v1))
      (call $push (local.get $v2)))
  
    (func $dug (param $n i32) (result)
      (local $idx i32)
      (local $loop_idx i32)
      (local $sp' i32)
      (local $top i64)
      (local.set $sp' (i32.add (global.get $sp) (local.get $n)))
      (i32.mul (i32.const 8) (local.tee $idx (global.get $sp)))
      (local.tee $loop_idx)
      i64.load
      local.set $top
      (loop $loop
        (i32.mul (i32.const 8) (local.get $idx))
        (i32.mul (i32.const 8) (i32.add (local.get $loop_idx) (i32.const 1)))
        local.tee $loop_idx
        i64.load
        i64.store
        (local.set $idx (i32.add (local.get $idx) (i32.const 1)))
        (local.get $idx)
        (local.get $sp')
        i32.lt_u
        br_if $loop)
  
      (i64.store (i32.mul (i32.const 8) (local.get $sp')) (local.get $top)))
  
    (func $dig (param $n i32) (result)
      (local $idx i32)
      (local $loop_idx i32)
      (local $sp' i32)
      (local $digged i64)
      (local.set $sp' (global.get $sp))
      (i32.mul (i32.const 8) (local.tee $idx (i32.add (local.get $sp') (local.get $n))))
      (local.tee $loop_idx)
      (i64.load)
      local.set $digged
      (loop $loop
        (i32.mul (i32.const 8) (local.get $idx))
        (i32.sub (local.get $loop_idx) (i32.const 1))
        local.tee $loop_idx
        i32.const 8
        i32.mul
        i64.load
        i64.store
        (local.set $idx (i32.sub (local.get $idx) (i32.const 1)))
        (local.get $sp')
        (local.get $loop_idx)
        i32.lt_u
        br_if $loop)
      (i64.store (i32.mul (i32.const 8) (global.get $sp)) (local.get $digged)))
  
    (func $pop (result i64)
      (local $spp i32)
      (i32.mul (i32.const 8) (local.tee $spp (global.get $sp)))
      i64.load
      (global.set $sp (i32.add (local.get $spp) (i32.const 1))))  ;;set stackptr
  
    (func $push (param $value i64) (result)
      (local $spp i32)
      (i32.mul (i32.const 8) (local.tee $spp (i32.sub (global.get $sp) (i32.const 1)) ))
      (i64.store (local.get $value))
      (global.set $sp (local.get $spp)))  ;;set stackptr
  
    (func $drop (param $n i32) (result)
      (global.set $sp (i32.add (global.get $sp) (local.get $n))))  ;;set stackptr
  
    (table $closures funcref (elem $iter_lambda.2 $iter_lambda.3 $lambda.1))
  (func $iter_lambda.2 (local $1 i64) (call $swap)
  (call $dup (i32.const 1))
  (call $dup (i32.const 3))
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dup (i32.const 4))
  (call $swap)
  (call $push (call $exec (call $pop) (call $pop)))
  (call $swap)
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dup (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $iter (call $pop) (table.get $closures (i32.const 1) (; $iter_lambda.3 ;) )))
  (call $unpair (call $pop))
  (call $swap)
  (call $push (call $some (call $pop)))
  (call $dig (i32.const 2))
  (call $push (call $car (call $pop)))
  (call $push (call $update (call $pop) (call $pop) (call $pop))))
  (func $iter_lambda.3 (local $1 i64) (call $swap)
  (call $unpair (call $pop))
  (call $dup (i32.const 1))
  (call $dup (i32.const 4))
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dup (i32.const 6))
  (call $swap)
  (call $push (call $exec (call $pop) (call $pop)))
  (call $dup (i32.const 4))
  (call $push (call $get_n (i32.const 4) (call $pop)))
  (call $dup (i32.const 1))
  (call $dup (i32.const 5))
  (call $push (call $car (call $pop)))
  (call $push (call $z_sub (call $pop) (call $pop)))
  (call $push (call $const (i32.const 2))) (; 0 ;)
  (call $dup (i32.const 2))
  (call $push (call $compare (call $pop) (call $pop)))
  (call $push (call $lt (call $pop)))
  (call $deref_bool (call $pop)) (if (then (call $push (call $const (i32.const 3))) (; "FA2_INSUFFICIENT_BALANCE" ;)
  (call $failwith (call $pop)) unreachable) (else ))
  (call $dig (i32.const 4))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $abs (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dup (i32.const 3))
  (call $push (call $cdr (call $pop)))
  (call $dig (i32.const 2))
  (call $dig (i32.const 3))
  (call $push (call $car (call $pop)))
  (call $push (call $z_add (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $const (i32.const 4))) (; 0 ;)
  (call $dup (i32.const 5))
  (call $push (call $get_n (i32.const 3) (call $pop)))
  (call $push (call $compare (call $pop) (call $pop)))
  (call $push (call $neq (call $pop)))
  (call $deref_bool (call $pop)) (if (then (call $push (call $const (i32.const 5))) (; "FA2_TOKEN_UNDEFINED" ;)
  (call $failwith (call $pop)) unreachable) (else ))
  (call $push (call $sender))
  (call $dup (i32.const 4))
  (call $dup (i32.const 7))
  (call $push (call $car (call $pop)))
  (call $push (call $map_get (call $pop) (call $pop)))
  (call $if_none (call $pop)) (if (then (call $dup (i32.const 8))) (else ))
  (call $push (call $cdr (call $pop)))
  (call $dup (i32.const 2))
  (call $push (call $mem (call $pop) (call $pop)))
  (call $push (call $not (call $pop)))
  (call $dup (i32.const 7))
  (call $push (call $car (call $pop)))
  (call $dig (i32.const 2))
  (call $push (call $compare (call $pop) (call $pop)))
  (call $push (call $neq (call $pop)))
  (call $push (call $or (call $pop) (call $pop)))
  (call $deref_bool (call $pop)) (if (then (call $push (call $const (i32.const 6))) (; "FA2_NOT_OPERATOR" ;)
  (call $failwith (call $pop)) unreachable) (else ))
  (call $swap)
  (call $dug (i32.const 2))
  (call $push (call $some (call $pop)))
  (call $dig (i32.const 3))
  (call $push (call $car (call $pop)))
  (call $push (call $update (call $pop) (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop))))
  (func $lambda.1 (local $1 i64) (call $unpair (call $pop))
  (call $swap)
  (call $unpair (call $pop))
  (call $push (call $map_get (call $pop) (call $pop)))
  (call $if_none (call $pop)) (if (then ) (else (call $swap)
  (call $drop (i32.const 1)))))
  
    (func $main (param $v1 i64) (result i64)
      (local $1 i64)
      (call $push (local.get $v1))
      (call $push (call $empty_set))
  (call $push (call $const (i32.const 0))) (; 0 ;)
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $closure (i32.const 0) (; $lambda.1 ;) ))
  (call $dup (i32.const 2))
  (call $push (call $apply (call $pop) (call $pop)))
  (call $dig (i32.const 2))
  (call $unpair (call $pop))
  (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $drop (i32.const 4))
  (call $push (call $const (i32.const 1))) (; "FA2_NOT_SUPPORTED" ;)
  (call $failwith (call $pop)) unreachable) (else (call $push (call $iter (call $pop) (table.get $closures (i32.const 2) (; $iter_lambda.2 ;) )))
  (call $swap)
  (call $dig (i32.const 2))
  (call $drop (i32.const 2))
  (call $push (call $nil))
  (call $push (call $pair (call $pop) (call $pop)))))) (else (call $drop (i32.const 4))
  (call $push (call $const (i32.const 7))) (; "FA2_NOT_SUPPORTED" ;)
  (call $failwith (call $pop)) unreachable))
      (call $pop))
  
    (export "push" (func $push))
    (export "pop" (func $push))
    (export "main" (func $main)))
  


Quipuswap FA2 contract
  $ ../bin/tunacc_test.exe DexFA2.tz
  
  (module
    (import "env" "pair" (func $pair (param i64 i64) (result i64)))
  (import "env" "unpair" (func $unpair (param i64)))
  (import "env" "z_add" (func $z_add (param i64 i64) (result i64)))
  (import "env" "z_sub" (func $z_sub (param i64 i64) (result i64)))
  (import "env" "compare" (func $compare (param i64 i64) (result i64)))
  (import "env" "car" (func $car (param i64) (result i64)))
  (import "env" "cdr" (func $cdr (param i64) (result i64)))
  (import "env" "some" (func $some (param i64) (result i64)))
  (import "env" "nil" (func $nil (result i64)))
  (import "env" "zero" (func $zero (result i64)))
  (import "env" "empty_set" (func $empty_set (result i64)))
  (import "env" "sender" (func $sender (result i64)))
  (import "env" "map_get" (func $map_get (param i64 i64) (result i64)))
  (import "env" "mem" (func $mem (param i64 i64) (result i64)))
  (import "env" "update" (func $update (param i64 i64 i64) (result i64)))
  (import "env" "iter" (func $iter (param i64 funcref) (result i64)))
  (import "env" "if_left" (func $if_left (param i64) (result i32)))
  (import "env" "if_none" (func $if_none (param i64) (result i32)))
  (import "env" "if_cons" (func $if_cons (param i64) (result i32)))
  (import "env" "isnat" (func $isnat (param i64) (result i64)))
  (import "env" "not" (func $not (param i64) (result i64)))
  (import "env" "or" (func $or (param i64 i64) (result i64)))
  (import "env" "deref_bool" (func $deref_bool (param i64) (result i32)))
  (import "env" "neq" (func $neq (param i64) (result i64)))
  (import "env" "failwith" (func $failwith (param i64)))
  (import "env" "get_n" (func $get_n (param i32 i64) (result i64)))
  (import "env" "exec" (func $exec (param i64 i64) (result i64)))
  (import "env" "apply" (func $apply (param i64 i64) (result i64)))
  (import "env" "const" (func $const (param i32) (result i64)))
  (import "env" "get_some" (func $get_some (param i64) (result i64)))
  (import "env" "abs" (func $abs (param i64) (result i64)))
  (import "env" "lt" (func $lt (param i64) (result i64)))
  (import "env" "closure" (func $closure (param i32) (result i64)))
  (import "env" "left" (func $left (param i64) (result i64)))
  (import "env" "right" (func $right (param i64) (result i64)))
  (import "env" "cons" (func $cons (param i64 i64) (result i64)))
  (import "env" "transfer_tokens" (func $transfer_tokens (param i64 i64 i64) (result i64)))
  (import "env" "address" (func $address (param i64) (result i64)))
  (import "env" "self" (func $self (result i64)))
  
    (global $mode i32 (i32.const 0))
  
    (memory 1)
    (global $sp (mut i32) (i32.const 4000)) ;; stack pointer
    (global $sh_sp (mut i32) (i32.const 1000)) ;;shadow_stack stack pointer
  
    (global $__stack_base i32 (i32.const 32768))
  
    (func $dip (param $n i32) (result)
      (local $stop i32)
      (local $sp' i32)
      (local $sh_sp' i32)
      (local.set $stop (i32.const 0))
      (local.set $sp'  (global.get $sp))
      (local.tee $sh_sp' (i32.sub (global.get $sh_sp) (local.get $n)))
      global.set $sh_sp
      (loop $l
        (i32.mul (i32.const 8) (i32.add (global.get $__stack_base) (i32.add (local.get $sh_sp') (local.get $stop))))
        (i64.load (i32.mul (i32.const 8) (i32.add (local.get $sp') (local.get $stop))))
        i64.store
        (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))
        (local.get $n)
        i32.ne
        br_if $l)
  
      (global.set $sp
      (i32.add
        (local.get $sp') (local.get $n))))
  
    (func $undip (param $n i32) (result)
      (local $stop i32)
      (local $sp' i32)
      (local $sh_sp' i32)
      (local.tee $sp'  (i32.sub (global.get $sp) (local.get $n)))
      global.set $sp
      (local.set $sh_sp' (global.get $sh_sp))
      (local.set $stop (i32.const 0))
      (loop $l
        (i32.mul (i32.const 8) (i32.add (local.get $sp') (local.get $stop)))
        (i64.load
          (i32.add
            (global.get $__stack_base)
            (i32.mul (i32.const 8) (i32.add (local.get $sh_sp') (local.get $stop)))))
        (i64.store)
        (local.tee $stop (i32.add (local.get $stop) (i32.const 1)))
        (local.get $n)
        i32.ne
        br_if $l)
      (global.set $sh_sp (i32.add (local.get $sh_sp') (local.get $n))))
  
    (func $dup (param $n i32) (result)
      (i64.load (i32.mul (i32.const 8) (i32.add (global.get $sp) (local.get $n))))
      (call $push))
  
    (func $swap (param) (result)
      (local $v1 i64)
      (local $v2 i64)
      (local.set $v1 (call $pop))
      (local.set $v2 (call $pop))
      (call $push (local.get $v1))
      (call $push (local.get $v2)))
  
    (func $dug (param $n i32) (result)
      (local $idx i32)
      (local $loop_idx i32)
      (local $sp' i32)
      (local $top i64)
      (local.set $sp' (i32.add (global.get $sp) (local.get $n)))
      (i32.mul (i32.const 8) (local.tee $idx (global.get $sp)))
      (local.tee $loop_idx)
      i64.load
      local.set $top
      (loop $loop
        (i32.mul (i32.const 8) (local.get $idx))
        (i32.mul (i32.const 8) (i32.add (local.get $loop_idx) (i32.const 1)))
        local.tee $loop_idx
        i64.load
        i64.store
        (local.set $idx (i32.add (local.get $idx) (i32.const 1)))
        (local.get $idx)
        (local.get $sp')
        i32.lt_u
        br_if $loop)
  
      (i64.store (i32.mul (i32.const 8) (local.get $sp')) (local.get $top)))
  
    (func $dig (param $n i32) (result)
      (local $idx i32)
      (local $loop_idx i32)
      (local $sp' i32)
      (local $digged i64)
      (local.set $sp' (global.get $sp))
      (i32.mul (i32.const 8) (local.tee $idx (i32.add (local.get $sp') (local.get $n))))
      (local.tee $loop_idx)
      (i64.load)
      local.set $digged
      (loop $loop
        (i32.mul (i32.const 8) (local.get $idx))
        (i32.sub (local.get $loop_idx) (i32.const 1))
        local.tee $loop_idx
        i32.const 8
        i32.mul
        i64.load
        i64.store
        (local.set $idx (i32.sub (local.get $idx) (i32.const 1)))
        (local.get $sp')
        (local.get $loop_idx)
        i32.lt_u
        br_if $loop)
      (i64.store (i32.mul (i32.const 8) (global.get $sp)) (local.get $digged)))
  
    (func $pop (result i64)
      (local $spp i32)
      (i32.mul (i32.const 8) (local.tee $spp (global.get $sp)))
      i64.load
      (global.set $sp (i32.add (local.get $spp) (i32.const 1))))  ;;set stackptr
  
    (func $push (param $value i64) (result)
      (local $spp i32)
      (i32.mul (i32.const 8) (local.tee $spp (i32.sub (global.get $sp) (i32.const 1)) ))
      (i64.store (local.get $value))
      (global.set $sp (local.get $spp)))  ;;set stackptr
  
    (func $drop (param $n i32) (result)
      (global.set $sp (i32.add (global.get $sp) (local.get $n))))  ;;set stackptr
  
    (table $closures funcref (elem ))
  
  
    (func $main (param $v1 i64) (result i64)
      (local $1 i64)
      (call $push (local.get $v1))
      (call $dup (i32.const 1))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $push (call $self))
  (call $push (call $address (call $pop)))
  (call $swap)
  (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $dig (i32.const 2))
  (call $push (call $const (i32.const 0))) (; 2 ;)
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dug (i32.const 2))
  (call $push (call $left (call $pop)))
  (call $push (call $left (call $pop)))
  (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $map_get (call $pop) (call $pop)))
  (call $if_none (call $pop)) (if (then (call $swap)
  (call $drop (i32.const 1))
  (call $swap)
  (call $drop (i32.const 1))
  (call $push (call $const (i32.const 1))) (; "Dex/function-not-set" ;)
  (call $failwith (call $pop)) unreachable) (else (call $dig (i32.const 3))
  (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $dug (i32.const 3))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $dig (i32.const 4))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $exec (call $pop) (call $pop)))))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dig (i32.const 2))
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))) (else (call $drop (i32.const 2))
  (call $dup (i32.const 1))
  (call $push (call $car (call $pop)))
  (call $push (call $car (call $pop)))
  (call $push (call $const (i32.const 2))) (; 8 ;)
  (call $push (call $map_get (call $pop) (call $pop)))
  (call $if_none (call $pop)) (if (then (call $push (call $const (i32.const 3))) (; "Dex/function-not-set" ;)
  (call $failwith (call $pop)) unreachable) (else (call $push (call $self))
  (call $push (call $address (call $pop)))
  (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $dug (i32.const 3))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $push (call $const (i32.const 4))) (; 0 ;)
  (call $push (call $right (call $pop)))
  (call $push (call $left (call $pop)))
  (call $push (call $left (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $exec (call $pop) (call $pop)))))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dig (i32.const 2))
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))))) (else (call $if_left (call $pop)) (if (then (call $swap)
  (call $drop (i32.const 1))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $nil))
  (call $dig (i32.const 2))
  (call $push (call $const (i32.const 5))) (; 0 ;)
  (call $dig (i32.const 4))
  (call $dup (i32.const 1))
  (call $dug (i32.const 5))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $push (call $car (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $dig (i32.const 5))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $push (call $car (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $transfer_tokens (call $pop) (call $pop) (call $pop)))
  (call $push (call $cons (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))) (else (call $dig (i32.const 2))
  (call $push (call $const (i32.const 6))) (; 0 ;)
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dug (i32.const 2))
  (call $push (call $right (call $pop)))
  (call $push (call $left (call $pop)))
  (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $map_get (call $pop) (call $pop)))
  (call $if_none (call $pop)) (if (then (call $swap)
  (call $drop (i32.const 1))
  (call $swap)
  (call $drop (i32.const 1))
  (call $push (call $const (i32.const 7))) (; "Dex/function-not-set" ;)
  (call $failwith (call $pop)) unreachable) (else (call $dig (i32.const 3))
  (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $dug (i32.const 3))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $dig (i32.const 4))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $exec (call $pop) (call $pop)))))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dig (i32.const 2))
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))))))) (else (call $if_left (call $pop)) (if (then (call $dig (i32.const 2))
  (call $push (call $const (i32.const 8))) (; 1 ;)
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dug (i32.const 2))
  (call $push (call $right (call $pop)))
  (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $push (call $map_get (call $pop) (call $pop)))
  (call $if_none (call $pop)) (if (then (call $swap)
  (call $drop (i32.const 1))
  (call $swap)
  (call $drop (i32.const 1))
  (call $push (call $const (i32.const 9))) (; "Dex/function-not-set" ;)
  (call $failwith (call $pop)) unreachable) (else (call $dig (i32.const 3))
  (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $dug (i32.const 3))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $dig (i32.const 4))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $exec (call $pop) (call $pop)))))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dig (i32.const 2))
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))) (else (call $dig (i32.const 2))
  (call $dup (i32.const 1))
  (call $dug (i32.const 3))
  (call $push (call $car (call $pop)))
  (call $push (call $car (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $drop (i32.const 1))
  (call $push (call $const (i32.const 10))) (; 5 ;)) (else (call $drop (i32.const 1))
  (call $push (call $const (i32.const 11))) (; 0 ;)))) (else (call $if_left (call $pop)) (if (then (call $drop (i32.const 1))
  (call $push (call $const (i32.const 12))) (; 4 ;)) (else (call $drop (i32.const 1))
  (call $push (call $const (i32.const 13))) (; 1 ;)))))) (else (call $if_left (call $pop)) (if (then (call $if_left (call $pop)) (if (then (call $drop (i32.const 1))
  (call $push (call $const (i32.const 14))) (; 2 ;)) (else (call $drop (i32.const 1))
  (call $push (call $const (i32.const 15))) (; 7 ;)))) (else (call $if_left (call $pop)) (if (then (call $drop (i32.const 1))
  (call $push (call $const (i32.const 16))) (; 6 ;)) (else (call $drop (i32.const 1))
  (call $push (call $const (i32.const 17))) (; 3 ;)))))))
  (call $push (call $map_get (call $pop) (call $pop)))
  (call $if_none (call $pop)) (if (then (call $drop (i32.const 2))
  (call $push (call $const (i32.const 18))) (; "Dex/function-not-set" ;)
  (call $failwith (call $pop)) unreachable) (else (call $dig (i32.const 2))
  (call $dig (i32.const 3))
  (call $dup (i32.const 1))
  (call $dug (i32.const 4))
  (call $push (call $cdr (call $pop)))
  (call $push (call $car (call $pop)))
  (call $dig (i32.const 3))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $push (call $exec (call $pop) (call $pop)))))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $cdr (call $pop)))
  (call $swap)
  (call $dup (i32.const 1))
  (call $dug (i32.const 2))
  (call $push (call $cdr (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $dig (i32.const 2))
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))
  (call $swap)
  (call $push (call $car (call $pop)))
  (call $push (call $pair (call $pop) (call $pop)))))))
      (call $pop))
  
    (export "push" (func $push))
    (export "pop" (func $push))
    (export "main" (func $main)))
  

